# @title Import necessary libraries
import os
import sys
sys.path.append(os.path.abspath(os.path.dirname(__file__)))

import asyncio
from google.adk.agents import Agent, LlmAgent
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner
from google.genai import types # For creating message Content/Parts
from typing import Optional 
from dotenv import load_dotenv
from tools.tools import save_report, save_user_manual, save_usecase_acceptance_criteria
from prompt import BRD_instruction, Business_analyst_instruction, BRD_Revision_Instruction, Usermanual_instruction, usecase_acceptance_criteria_instruction
from google.adk.tools import google_search
# from subagents.BRDGeneratorAgent.agent import BRDGeneratorAgent
import warnings
# Ignore all warnings
warnings.filterwarnings("ignore")

import logging
logging.basicConfig(level=logging.ERROR)

print("Libraries imported.")

try:
    from dotenv import load_dotenv
    load_dotenv()

    MODEL_NAME = os.environ.get("GOOGLE_GENAI_MODEL", "gemini-2.0-flash")
except ImportError:
    print("Warning: python-dotenv not installed. Ensure API key is set")
    MODEL_NAME = "gemini-2.0-flash"


MODEL_GEMINI_2_0_FLASH = "gemini-2.0-flash" # Starting with Gemini



# BRD Generator Agent
BRDGeneratorAgent = Agent(
        # Can use the same or a different model
        model = MODEL_GEMINI_2_0_FLASH,
        # model=LiteLlm(model=MODEL_GPT_4O), # If you would like to experiment with other models
        name="BRDGeneratorAgent",
        instruction=BRD_instruction,
        description="You create clear, structured Business Requirement Documents by analyzing stakeholder inputs, business goals, functional needs and mandatorily save the report using 'save_report' tool", # Crucial for delegation
        tools=[save_report],
    )

BRDRevisionAgent = Agent(
        model = MODEL_GEMINI_2_0_FLASH,
        # model=LiteLlm(model=MODEL_GPT_4O), # If you would like to experiment with other models
        name="BRDRevisionAgent",
        instruction=BRD_Revision_Instruction,
        description="You are a BRD revision agent. You understand the user changes and change the BRD document given to you which is generated by the BRDGeneratorAgent. Save the report using 'save_report' tool.", # Crucial for delegation
        tools=[save_report],
    )
UserManualAgent = Agent(
        model = MODEL_GEMINI_2_0_FLASH,
        # model=LiteLlm(model=MODEL_GPT_4O), # If you would like to experiment with other models
        name="UserManualAgent",
        instruction=Usermanual_instruction,
        description="You are a user manual agent. You understand the product details given by the user and create a user manual for the product. Save the report using 'save_user_manual' tool.", # Crucial for delegation
        tools=[save_user_manual],
    )
UsecaseAcceptanceCriteriaAgent = Agent(
        model = MODEL_GEMINI_2_0_FLASH,
        # model=LiteLlm(model=MODEL_GPT_4O), # If you would like to experiment with other models
        name="UsecaseAcceptanceCriteriaAgent",
        instruction=usecase_acceptance_criteria_instruction,
        description="You are a usecase acceptance criteria agent.  Given a short feature description or user story by the user and create usecase and acceptance criteria for the product. Save the report using 'save_user_manual' tool.", # Crucial for delegation
        tools=[save_usecase_acceptance_criteria],
    )

# --- Business Analyst Agent ---
business_analyst_agent = Agent(
        model = MODEL_GEMINI_2_0_FLASH,
        # model=LiteLlm(model=MODEL_GPT_4O), # If you would like to experiment with other models
        name="business_analyst_agent",
        instruction=Business_analyst_instruction,
        output_key="ba_output",
        description="You are a business analyst. You understand the business requirement and delegate the task to the subagents like 'BRDGeneratorAgent' and BRDRevisionAgent.", # Crucial for delegation
        sub_agents=[BRDGeneratorAgent, BRDRevisionAgent, UserManualAgent, UsecaseAcceptanceCriteriaAgent],
    )

root_agent=business_analyst_agent

# @title Setup Session Service and Runner

# --- Session Management ---
# Key Concept: SessionService stores conversation history & state.
# InMemorySessionService is simple, non-persistent storage for this tutorial.

async def call_agent_async(query: str, runner, user_id, session_id):
  """Sends a query to the agent and prints the final response."""
  print(f"\n>>> User Query: {query}")

  # Prepare the user's message in ADK format
  content = types.Content(role='user', parts=[types.Part(text=query)])

  final_response_text = "Agent did not produce a final response." # Default

  # Key Concept: run_async executes the agent logic and yields Events.
  # We iterate through events to find the final answer.
  async for event in runner.run_async(user_id=user_id, session_id=session_id, new_message=content):
      # You can uncomment the line below to see *all* events during execution
      # print(f"  [Event] Author: {event.author}, Type: {type(event).__name__}, Final: {event.is_final_response()}, Content: {event.content}")

      # Key Concept: is_final_response() marks the concluding message for the turn.
      if event.is_final_response():
          if event.content and event.content.parts:
             # Assuming text response in the first part
             final_response_text = event.content.parts[0].text
          elif event.actions and event.actions.escalate: # Handle potential errors/escalations
             final_response_text = f"Agent escalated: {event.error_message or 'No specific message.'}"
          # Add more checks here if needed (e.g., specific error codes)
          break # Stop processing events once the final response is found

  print(f"<<< Agent Response: {final_response_text}")
         

async def run_c():
    session_service = InMemorySessionService()

    # Define constants for identifying the interaction context
    APP_NAME = "business_analyst_app"
    USER_ID = "user_1"
    SESSION_ID = "session_001" # Using a fixed ID for simplicity

    # Create the specific session where the conversation will happen
    session = await session_service.create_session(
        app_name=APP_NAME,
        user_id=USER_ID,
        session_id=SESSION_ID
    )
    print(f"Session created: App='{APP_NAME}', User='{USER_ID}', Session='{SESSION_ID}'")

    # --- Runner ---
    # Key Concept: Runner orchestrates the agent execution loop.
    runner = Runner(
        agent=root_agent, # The agent we want to run
        app_name=APP_NAME,   # Associates runs with our app
        session_service=session_service # Uses our session manager
    )
    print(f"Runner created for agent '{runner.agent.name}'.")

    await call_agent_async("The client needs an internal tool for automating leave approvals. It should integrate with their existing HRMS. Only managers can approve or reject leave. Employees should be able to see their leave history and balance. The tool should be browser-based and mobile-friendly. The initial rollout will be for 3 departments. Launch expected in Q4.",runner=runner,user_id=USER_ID,session_id=SESSION_ID)


# if __name__=="__main__":
#     asyncio.run(run_c())

# The client needs an internal tool for automating leave approvals. It should integrate with their existing HRMS. Only managers can approve or reject leave. Employees should be able to see their leave history and balance. The tool should be browser-based and mobile-friendly. The initial rollout will be for 3 departments. Launch expected in Q4.